package printer

import (
	"bytes"
	goformat "go/format"
	goparser "go/parser"
	gotoken "go/token"
	"io"
	"regexp"
	"text/template"

	"github.com/amenzhinsky/dbus-codegen-go/token"
)

// PrintOption is a Print+ configuration option.
type PrintOption func(ctx *context)

// WithPackageName overrides the package name of generated code.
func WithPackageName(name string) PrintOption {
	return func(ctx *context) {
		ctx.PackageName = name
	}
}

// WithGofmt gofmts generated code, enabled by default.
//
// Not recommended to disable it, only for debugging the output,
// because gofmt works as a validation step as well.
func WithGofmt(enable bool) PrintOption {
	return func(ctx *context) {
		ctx.gofmt = enable
	}
}

// WithPrefixes prefixes to strip from interface names, be careful
// when using it may lead to compilation errors.
func WithPrefixes(prefixes []string) PrintOption {
	return func(ctx *context) {
		ctx.prefixes = prefixes
	}
}

// WithServerOnly makes the printer generate only server-side code.
func WithServerOnly(enable bool) PrintOption {
	return func(ctx *context) {
		ctx.ServerOnly = enable
	}
}

// WithClientOnly makes the printer generate only client-side code.
func WithClientOnly(enable bool) PrintOption {
	return func(ctx *context) {
		ctx.ClientOnly = enable
	}
}

func WithCamelize(enable bool) PrintOption {
	return func(ctx *context) {
		ctx.camelize = enable
	}
}

var identRegexp = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]*$")

const clientTpl = `// Code generated by dbus-codegen-go DO NOT EDIT.
package {{.PackageName}}

import (
{{- range $import := .Imports}}
	"{{$import}}"
{{- end}}
)

{{if not $.ClientOnly -}}
var (
{{- range $iface := .Interfaces}}
	// Introspection for {{$iface.Name}}
	IntrospectData{{ifaceType $iface}} = introspect.Interface{
			Name: "{{$iface.RawInterface.Name}}",
			Methods: {{methodsString .RawInterface.Methods}}
			Signals: {{signalsString .RawInterface.Signals}}
			Properties: {{propsString .RawInterface.Properties}}
			Annotations:  {{annotationsString .RawInterface.Annotations}}
	}
{{- end}}
)
{{end -}}

{{if haveSignals .Interfaces}}
// Signal is a common interface for all signals.
type Signal interface {
	Name()      string
	Interface() string
	Sender()    string

	path()   dbus.ObjectPath
	values() []interface{}
}

{{if not $.ClientOnly -}}
// Emit sends the given signal to the bus.
func Emit(conn *dbus.Conn, s Signal) error {
	return conn.Emit(s.path(), s.Interface()+"."+s.Name(), s.values()...)
}
{{end -}}

{{if not $.ServerOnly}}
// ErrUnknownSignal is returned by LookupSignal when a signal cannot be resolved.
var ErrUnknownSignal = errors.New("unknown signal")

// LookupSignal converts the given raw D-Bus signal with variable body 
// into one with typed structured body or returns ErrUnknownSignal error.
func LookupSignal(signal *dbus.Signal) (Signal, error) {
	switch signal.Name {
{{- range $iface := .Interfaces}}
{{- range $signal := $iface.Signals}}
	case {{ifaceNameConst $iface}} + "." + "{{$signal.Name}}":
		if len(signal.Body) < {{len $signal.Args}} {
			return nil, fmt.Errorf("signal has %v args rather than the expected {{len $signal.Args}}", len(signal.Body))
		}
{{- range $i, $argument := $signal.Args}}
		v{{$i}}, ok := signal.Body[{{$i}}].({{$argument.Type}})
		if !ok {
			return nil, fmt.Errorf("prop .{{argName $argument "v" $i true}} is %T, not {{$argument.Type}}", signal.Body[{{$i}}])
		}
{{- end}}
		return &{{signalType $iface $signal}}{
			sender: signal.Sender,
			Path:   signal.Path,
			Body: &{{signalBodyType $iface $signal}}{
{{- range $i, $argument := $signal.Args}}
				{{argName $argument "v" $i true}}: v{{$i}},
{{- end}}
			},
		}, nil
{{- end}}
{{- end}}
	default:
		return nil, ErrUnknownSignal
	}
}

// AddMatchSignal registers a match rule for the given signal,
// opts are appended to the automatically generated signal's rules.
func AddMatchSignal(conn *dbus.Conn, s Signal, opts ...dbus.MatchOption) error {
	return conn.AddMatchSignal(append([]dbus.MatchOption{
		dbus.WithMatchInterface(s.Interface()),
		dbus.WithMatchMember(s.Name()),
	}, opts...)...)
}

// RemoveMatchSignal unregisters the previously registered subscription.
func RemoveMatchSignal(conn *dbus.Conn, s Signal, opts ...dbus.MatchOption) error {
	return conn.RemoveMatchSignal(append([]dbus.MatchOption{
		dbus.WithMatchInterface(s.Interface()),
		dbus.WithMatchMember(s.Name()),
	}, opts...)...)
}
{{end -}}
{{end -}}

// Interface name constants.
const (
{{- range $iface := .Interfaces}}
	{{ifaceNameConst $iface}} = "{{$iface.Name}}"
{{- end}}
)
{{- define "annotations"}}
{{- if ne (len .Annotations) 0 }}
//
// Annotations:
{{- range $annotation := .Annotations}}
//   @{{$annotation.Name}} = {{$annotation.Value}}
{{- end}}
{{- end}}
{{- end}}
{{range $iface := .Interfaces}}
{{if not $.ClientOnly -}}
// {{serverType $iface}} is {{$iface.Name}} interface.
type {{serverType $iface}} interface {
	{{range $method := $iface.Methods -}}
	// {{methodType $method}} is {{$iface.Name}}.{{$method.Name}} method.
	{{methodType $method}}({{joinMethodInArgs $method}}) ({{joinMethodOutArgs $method}}err *dbus.Error)
	{{end}}
}

// Export{{ifaceType $iface}} exports the given object that implements {{$iface.Name}} on the bus.
func Export{{ifaceType $iface}}(conn *dbus.Conn, path dbus.ObjectPath, v {{serverType $iface}}) error {
	n := &introspect.Node{
		Name: string(path),
		Interfaces:[]introspect.Interface{
			IntrospectData{{ifaceType $iface}},
		},
	}
	err := conn.Export(introspect.NewIntrospectable(n), path, "org.freedesktop.DBus.Introspectable")
	if err != nil {
		return err
	}
	return conn.ExportSubtreeMethodTable(map[string]interface{}{
		{{range $method := $iface.Methods -}}
		"{{$method.Name}}": v.{{methodType $method}},
		{{end -}} 
	}, path, {{ifaceNameConst $iface}})
}

// Unexport{{ifaceType $iface}} unexports {{$iface.Name}} interface on the named path.
func Unexport{{ifaceType $iface}}(conn *dbus.Conn, path dbus.ObjectPath) error {
	return conn.Export(nil, path, {{ifaceNameConst $iface}})
}

// {{unimplementedType $iface}} can be embedded to have forward compatible server implementations.
type {{unimplementedType $iface}} struct{}

func (*{{unimplementedType $iface}}) iface() string {
	return {{ifaceNameConst $iface}}
}

{{range $method := $iface.Methods -}}
func (*{{unimplementedType $iface}}) {{methodType $method}}({{joinMethodInArgs $method}}) ({{joinMethodOutArgs $method}}err *dbus.Error) {
	err = &dbus.ErrMsgUnknownMethod
	return
}

{{end}}
{{- end}}

{{if not $.ServerOnly -}}
// New{{ifaceType $iface}} creates and allocates {{$iface.Name}}.
func New{{ifaceType $iface}}(object dbus.BusObject) *{{ifaceType $iface}} {
	return &{{ifaceType $iface}}{object}
}

// {{ifaceType $iface}} implements {{$iface.Name}} D-Bus interface.
{{- template "annotations" $iface}}
type {{ifaceType $iface}} struct {
	object dbus.BusObject
}

{{range $method := $iface.Methods}}
// {{methodType $method}} calls {{$iface.Name}}.{{$method.Name}} method.
{{- if methodIsDeprecated $method}}
//
// Deprecated will be removed later.
{{- end}}
{{- template "annotations" $method}}
func (o *{{ifaceType $iface}}) {{methodType $method}}(ctx context.Context, {{joinMethodInArgs $method}}) ({{joinMethodOutArgs $method}}err error) {
	err = o.object.CallWithContext(ctx, {{ifaceNameConst $iface}} + ".{{$method.Name}}", {{methodFlags $method}}, {{joinArgNames $method.In}}).Store({{joinStoreArgs $method.Out}})
	return
}
{{end}}
{{- range $prop := $iface.Properties}}
{{- if propNeedsGet $iface $prop}}
// {{propGetType $prop}} gets {{$iface.Name}}.{{$prop.Name}} property.
{{- template "annotations" $prop}}
func (o *{{ifaceType $iface}}) {{propGetType $prop}}(ctx context.Context) ({{propArgName $prop}} {{$prop.Arg.Type}}, err error) {
	err = o.object.CallWithContext(ctx, "org.freedesktop.DBus.Properties.Get", 0, {{ifaceNameConst $iface}}, "{{$prop.Name}}").Store(&{{propArgName $prop}})
	return
}
{{- end}}
{{- if propNeedsSet $iface $prop}}
// {{propSetType $prop}} sets {{$iface.Name}}.{{$prop.Name}} property.
{{- template "annotations" $prop}}
func (o *{{ifaceType $iface}}) {{propSetType $prop}}(ctx context.Context, {{propArgName $prop}} {{$prop.Arg.Type}}) error {
	return o.object.CallWithContext(ctx, "org.freedesktop.DBus.Properties.Set", 0, {{ifaceNameConst $iface}}, "{{$prop.Name}}", dbus.MakeVariant({{propArgName $prop}})).Store()
}
{{- end}}
{{end}}
{{range $signal := $iface.Signals}}
// {{signalType $iface $signal}} represents {{$iface.Name}}.{{$signal.Name}} signal.
{{- template "annotations" $signal}}
type {{signalType $iface $signal}} struct {
	sender string
	Path   dbus.ObjectPath
	Body   *{{signalBodyType $iface $signal}}
}

// Name returns the signal's name.
func (s *{{signalType $iface $signal}}) Name() string {
	return "{{$signal.Name}}"
}

// Interface returns the signal's interface.
func (s *{{signalType $iface $signal}}) Interface() string {
	return {{ifaceNameConst $iface}}
}

// Sender returns the signal's sender unique name.
func (s *{{signalType $iface $signal}}) Sender() string {
	return s.sender
}

func (s *{{signalType $iface $signal}}) path() dbus.ObjectPath {
	return s.Path
}

func (s *{{signalType $iface $signal}}) values() []interface{} {
	return []interface{}{{"{"}}{{joinSignalValues "s.Body." $signal}}{{"}"}}
}

// {{signalBodyType $iface $signal}} is body container.
type {{signalBodyType $iface $signal}} struct {
	{{joinSignalArgs $signal}}
}
{{end}}
{{- end}}
{{- end}}`

func Print(out io.Writer, ifaces []*token.Interface, opts ...PrintOption) error {
	ctx, err := newContext(ifaces, opts...)
	if err != nil {
		return err
	}

	ctx.addImport("github.com/godbus/dbus/v5")

	if !ctx.ClientOnly {
		ctx.addImport("github.com/godbus/dbus/v5/introspect")
	}

	if !ctx.ServerOnly {
		ctx.addImport("context")
		if haveSignals(ifaces) {
			ctx.addImport("fmt")
			ctx.addImport("errors")
		}
	}

	var buf bytes.Buffer
	// if err = template.Must(ctx.tpl.Parse(clientTpl)).Execute(os.Stdout, ctx); err != nil {
	// 	return err
	// }
	if err = template.Must(ctx.tpl.Parse(clientTpl)).Execute(&buf, ctx); err != nil {
		return err
	}
	if ctx.gofmt {
		fset := gotoken.NewFileSet()
		file, err := goparser.ParseFile(fset, "", buf.Bytes(), goparser.ParseComments)
		if err != nil {
			// TODO: print helpful message
			// if _, ok := err.(scanner.ErrorList); ok {
			// 	return errors.New("unable to parse generated code")
			// }
			return err
		}
		return goformat.Node(out, fset, file)
	}
	_, err = out.Write(buf.Bytes())
	return err
}

func haveSignals(ifaces []*token.Interface) bool {
	for _, iface := range ifaces {
		if len(iface.Signals) != 0 {
			return true
		}
	}
	return false
}
